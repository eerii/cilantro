# Como aprender Python sen morrer no intento üêç
~¬†joseko

- [Como aprender Python sen morrer no intento üêç](#como-aprender-python-sen-morrer-no-intento-)
  - [Antes de comezar](#antes-de-comezar)
    - [Comentarios](#comentarios)
    - [Imprimir calqueira cousa](#imprimir-calqueira-cousa)
  - [Variables](#variables)
    - [Tipos b√°sicos](#tipos-b√°sicos)
    - [Problemas entre tipos](#problemas-entre-tipos)
    - [Asignar variables](#asignar-variables)
    - [Operadores aritm√©ticos](#operadores-aritm√©ticos)
  - [L√≥xica](#l√≥xica)
    - [Operadores l√≥xicos](#operadores-l√≥xicos)
    - [Operadores de comparaci√≥n](#operadores-de-comparaci√≥n)
    - [Bloque if](#bloque-if)
    - [Indentaci√≥n](#indentaci√≥n)
    - [Bloque else](#bloque-else)
    - [Bloque elif](#bloque-elif)
  - [Funci√≥ns](#funci√≥ns)
    - [Argumentos](#argumentos)

## Antes de comezar

### Comentarios

```python
# esto √© un comentario
a = 3 # p√≥dense po√±er onde queiras con un '#'
print(a) # √© moi importante documentar o c√≥digo para saber o que fai
```

### Imprimir calqueira cousa

√â fundamental poder ver o que est√° ocurrindo dentro do programa. Hai varias maneiras de facer iso, pero a que m√°is vamos a utilizar √© `print`. Esta funci√≥n imprime o que lle po√±as dentro na consola, xa sexa o valor dunha [variable](#variables), un n√∫mero ou algo m√°is complexo.

Coma calqueira [funci√≥n](#funci√≥ns) ch√°mase escribindo o nome e abrindo par√©nteses. Dentro escribes os [argumentos](#argumentos), separados por comas. Por exemplo:

```python
print("uwu")
```
```python
>> uwu
```

Nota: de aqu√≠ en adiante utilizarei o s√≠mbolo `>>` para representar o que imprime a consola cando executas o c√≥digo superior.

```python
print(3.14) # n√∫meros
print("uwu") # texto
print(a) # variables
print("cosas", 10, b) # varias cousas, sep√°ranse por comas
```

## Variables

As variables son o espacio onde gardas datos. Dec√°ranse da seguinte maneira:

```python
# nome = valor
x = 3
```

### Tipos b√°sicos

Poden ter varios tipos, pero en `python` non √© obligatorio especificalo antes de crear unha variable, simplemente te√±en o tipo do valor que lle asignas:

```python
numero = 1 # int
decimal = 3.14 # float
complexo = 0+1j # complex
texto = "hola" # str
condicion = True # bool
```

Podes obter o tipo dunha variable utilizando a funci√≥n `type`:

```python
print(type(3))
```
```python
>> int
```

Se te fixas chamamos directamente √° funci√≥n `print` co resultado da funci√≥n `type`. Isto √© totalmente v√°lido e aforra moito tempo en ocasi√≥ns.

### Problemas entre tipos

Os valores `3`, `3.0` e `"3"` son distintos: `3` √© un n√∫mero enteiro (`int`), `3.0` √© un n√∫mero decimal (`float`), e `"3"` √© un texto c√≥ caracter 3. Non darse conta da diferencia pode dar p√© a quebraderos de cabeza, xa que se intentas sumar un n√∫mero con un texto, o programa ter√° un erro.

Para evitar isto, fixate ben en como declaras as variables, e se tes dudas sempre podes utilizar `type()` para ver o tipo que ten unha variable nun momento dado.

Se queres convertir dun tipo a outro podes facer _casting_. Isto faise po√±endo o nome oficial do tipo e o valor a convertir entre par√©nteses. Por exemplo:

```python
x = str(3)    # x ser√° un texto co valor "3"
y = int(3)    # y ser√° un n√∫mero enteiro co valor 3
z = float(3)  # z ser√° un n√∫mero decimal co valor 3.0
```

### Asignar variables

Podes asignar unha variable (darlle valor) as veces que queiras, incluso a tipos diferentes (a√≠nda que para comezar √© recomendable non mezclar tipos para evitar confusi√≥ns).

```python
a = 3
b = 4

a = 10 # agora a vale 10
b = a + 5 # agora b vale 10+5=15

a = "hola" # pode facerse pero non √© moi recomendable
```

Cando asignas variables podes utllizar o valor de outra variable, como fixemos na pen√∫ltima li√±a, e operaci√≥ns entre elas.

Tam√©n podes utilizar o valor da mesma variable, por exemplo, `a = a + 1`, que aumentar√° o valor de `a` nunha unidade.

### Operadores aritm√©ticos

En `python` hai varios tipos de operadores. Comezaremos cos aritm√©ticos:

```python
a + b # suma
a - b # resta
a * b # multiplicaci√≥n
a / b # divisi√≥n
a % b¬†# m√≥dulo da divisi√≥n
a ** b # 'a' elevado a 'b'
```

Tam√©n temos o **operador asignaci√≥n**, que √© `=`, e asigna o valor da dereita √° variable da esquerda, como xa vimos. Adem√°is, hai uns operadores moi √∫tiles que mezclan os aritm√©ticos e o operador asignaci√≥n, como:

```python
a += b # esto √© equivamente a 'a = a + b'
```

Podes utilizar a suma, a resta ou calqueira dos outros operadores seguido do signo igual. Esto o que fai e sumarlle √≥ valor de a o que po√±as na man dereita. Por exemplo, incrementar unha variable nunha unidade `a = a + 1` p√≥dese resumir por `a += 1` (a√≠nda que ambas son equivalentes).

## L√≥xica

Gardar n√∫meros e outras cousas non nos serve de moito se non temos qu√© facer con eles. Para iso introduciremos a **l√≥xica booleana**, isto √©, que se basa en valores verdadeiros e falsos. O tipo `bool` pode tomar dous valores:

```python
a = True # verdadeiro, equivalente a 1
b = False # false, equivalente a 0
```

### Operadores l√≥xicos

Temos tres operadores l√≥xicos que modifican unha condici√≥n:

```python
# and : s√≥ √© verdadeiro se ambos son verdadeiros
True and True = True
True and False = False
False and False = False
```

```python
# or : √© verdadeiro se alg√∫n √© verdadeiro
True or True = True
True or False = True
False or False = False
```

```python
# not : invirte o valor
not True = False
not False = True
```

### Operadores de comparaci√≥n

Para comparar du√°s variables ou valores aparecen os operadores de comparaci√≥n. Estes **sempre** devolven un resultado `bool`, cun valor ou verdadeiro ou falso.

```python
a == b # igual : verdadeiro se a √© igual a b
a != b # non igual : verdadeiro se a √© distinto de b
a > b # maior : verdadeiro se a √© maior que b
a < b # menor : verdadeiro se a √© menor que b
a >= b # maior ou igual
a <= b # menor ou igual
```

Adem√°is, podes encadear varias comparaci√≥ns utilizando os operadores l√≥xicos:

```python
a != b and b > 0 # a √© distinto de b e b √© maior que 0
not a == b # a non √© igual a b (esto √© equivalente a: a != b)
a > b or c > d # a maior que b ou c maior que d
```

### Bloque if

Estaraste a preguntar para que serve toda esta l√≥xica. Podemos utilizala para **controlar** o programa.

O bloque `if` executara o c√≥digo no seu interior se a condici√≥n indicada se cumpre.

```python
if condicion:
  # executa isto
```

Por _condici√≥n_ refer√≠monos a un valor verdadeiro ou falso, que normalmente ven dado por un dos operadoradores de comparaci√≥n que xa vimos. O c√≥digo que execute pode ser **calqueira cousa**. Vamos facer un exemplo simple con `print`.

```python
if a > 3:
  print("a √© maior que 3")
```

Debemos fixarnos en dous detalles. Primeiro, a sintaxe do bloque `if` √© `if condicion:`, especial √©nfase nos dous puntos. Isto indica que remata a condici√≥n e comeza o c√≥digo a executar se esta se cumple.

### Indentaci√≥n

O segundo √© a **indentaci√≥n**. Noutras linguaxes de programaci√≥n para separar c√≥digo util√≠zanse os corchetes `{}`, sen embargo, `python` utiliza os espazos. Calqueira editor de `python` decente o far√° autom√°ticamente, pero √© moi importante indentar o c√≥digo. Todo o c√≥digo que est√© √≥ mesmo nivel de indentaci√≥n ser√° parte do mesmo bloque.

Vamos a ver un exemplo simple con `if`. Como sabe o programa qu√© c√≥digo ten que executar o bloque if, e onde contin√∫a o programa normal? Utilizando indentaci√≥n:

```python
a = 5

if a > 3:
  print("esto se executa se a √© maior que 3")

print("esto se executa sempre")
```

Se te fixas, d√≠ante do primeiro `print` hai dous espazos, que indican que est√° no seguinte nivel (sempre se usan dous espazos). O segundo `print` volve a estar no nivel base do programa.

Dentro do bloque `if` podemos po√±er **calqueira** c√≥digo, inclu√≠do outro bloque `if`:

```python
if a > 3:
  if b == 5:
    if c != 4:
      print("chegaches aqu√≠!")

# nota: este c√≥digo non √© moi elegante, pero est√° as√≠ para ilustrar
# os niveis de indentanci√≥n. un c√≥digo equivalente √©:
if a > 3 and b == 5 and c != 4:
  print("chegaches aqu√≠!")
```

Podes observar que cada bloque if aumenta a indentaci√≥n en dous espazos. Isto fai que podamos po√±er condici√≥ns anidadas. Adem√°is, tam√©n podemos facer o seguinte:

```python
if a > 3:
  if b == 5:
    print("hola")
  print("adeus")
```

Neste caso, se `a > 3`, primeiro comprobarase se `b == 5`. Se este √© o caso, imprimir√° "hola" na consola. Independentemente do que resulte o segundo `if`, logo imprimir√° "adeus". Isto √© as√≠ porque adeus est√° no nivel do primeiro `if`, polo que non depende do segundo para nada, como podemos ver a continuaci√≥n:

```python
if a > 3:
  #...
  print("adeus")
```

√â moi importante adoptar esta mentalidade de **bloques** indentados, e practicar para comprender o que est√° pasando. Mira o seguinte exemplo, m√°is complexo, pero cos mesmos bloques b√°sicos (non te centres demasiado nas funci√≥ns, simplemente na maneira que a indentaci√≥n √© importante):

```python
# movemento_x e movemento_y son variables
# mover_dereita() e comprobar_terra() son funci√≥ns arbitrarias
# comprobar_terra() devolve un valor verdadeiro ou falso

if movemento_x > 0: # vai cara a dereita
  if movemento_y == 0: # non se move na horizontal
    mover_dereita()
  if movemento_y > 0: # m√≥vese cara arriba na horizontal
    saltar()
    print("est√°s no aire!") # podes po√±er varias li√±as debaixo dun if
  if movemento_y < 0: # m√≥vese cara abaixo
    terra = comprobar_terra()
    if (terra):
      print("chocaches co chan!")
      movemento_y = 0 # deixas de moverte cara abaixo
```

### Bloque else

Adem√°is do bloque `if`, temos o seu compa√±eire, `else`. A sintaxe √© como segue:

```python
if a > 3:
  print("a √© maior que 3")
else:
  print("a non √© maior que 3")
```

Se queremos cubrir o caso no que a condici√≥n **non √© certa** podemos utilizar un `else` despo√≠s de todo o c√≥digo do `if`. Presta atenci√≥n √° indentaci√≥n, o bloque `else` col√≥case √° mesma altura que o `if` √≥ que complementa, e o seu c√≥digo ten unha indentaci√≥n m√°is, igual que o c√≥digo do `if`.

### Bloque elif

Nalgunas ocasi√≥ns queres ter un maior control no que o programa far√° dependendo da condici√≥n indicada. Para iso est√° `elif`. Desp√≥is dun `if` podes colocar este bloque **con outra condici√≥n**. Se _todo o anterior_ √© falso, pero a condici√≥n √© verdadeira, ent√≥n ese bloque executarase. Vamos velo mellor cun exemplo:

```python
if a % 2 == 0: # utlizando a operaci√≥n de m√≥dulo da divisi√≥n
  print("a √© par")
elif a > 2:
  print("a √© impar, e adem√°is maior que 2")
elif a > 0:
  print("a √© impar, menor ou igual a 2, e maior que cero")
```

Como ves as condici√≥ns vanse acumulando, e cada vez √© mais concreto. Tam√©n pode incluirse un `else` √≥ final para cubrir todas as opci√≥ns restantes (mentres que pode haber varios `elif`, s√≥ pode haber un `else` xa que este xa cubre todas as condici√≥ns que queden, e o `else` sempre debe ir √≥ final):

```python
if a > 3:
  print("a √© maior que 3")
elif a < 3:
  print("a √© menor que 3")
else:
  print("a √© 3")
```

## Funci√≥ns

### Argumentos

